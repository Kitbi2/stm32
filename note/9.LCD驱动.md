# LCD驱动

## 一、LCD显示图片的原理

1.先了解几个比较重要的概念：分辨率，尺寸，色位

2.分辨率：就是一块LCD屏幕上面有多少个像素点，或者说有多少个二极管。单位是x*x。

3.尺寸：LCD屏幕斜对角线的长度

4.色位：一个像素点用多少位来描述

### 1-1： LCD如何呈现出图像

1.我们说像素点也就是一个一个的发光二极管，我们要呈现一张图片出来就是把一张图片个个像素点的颜色通过LCD的发光二极管发出对于的光。

2.如何对颜色进行描述的一般是RGB888，也就是红绿蓝三种颜色每一种用8位的数据进行表述，

![image-20231221151347915](pic\image-20231221151347915.png)

3.320*480频率的一帧图片就是

```c
uint32_t pic[320][480] = { {32,2,32,32,23,43,656,56},{}.......  };
```

4.那么我们要显示图像就是根据我们图像数组（描述图像各个像素点的数组）让对于的发光二极管发出对应的光

### 1-2：LCD如何识别图像数组

1.这一步由于LCD的驱动芯片完成，我们只需要把像素点的数据发送给芯片，芯片就会帮我们完成转化



## 二、如何图像数组发送给LCD呢

1.单片机把图像数据写入到图像缓冲中，显示控制器把图像缓冲的内存进行分析，使LCD屏幕显示出对应的图案

![image-20231222192419071](pic\image-20231222192419071.png)

2.在市场上有俩种LCD屏幕，一种是把图像缓冲和控制器做到和LCD屏幕一起的（MPU屏幕），一种是没有图像缓冲的。这里我们介绍第一种，第二种等以后有机会了在介绍

### 2-1：MCU屏幕

1.MPU屏幕就是把缓冲帧和控制器封装到一起的屏幕，那么我们就不需要关注控制器是如何解析图像数据的，我们只需要关注如何把图像数据发送给LCD屏幕。

2.有三种接口：A类：基于Motorola 6800总线 B类：基于Intel 8080总线 C类：基于SPI协议。这里我们介绍B类接口，C类接口就是SPI协议，后面我们也会进行学习



### 2-2：8080总线

1.8080总线一共有16 + 4个引脚口，16是数据传输的引脚口，4分别是CS（器件片选），D/CX（命令/数据选择引脚口），RDX（写入使能），WRX（读取使能）

2.8080接口会根据IM的来选择模式（16，8，24位），DB[23:0]对应到数据位，DB[0]就是数据的第0位

3.CS引脚：该引脚用于片选设备，当该引脚位低的时候表示设备选中

4.WRX引脚：写信号，上升沿的时候表示写入数据/命令

5.RDX引脚：读信号，上升沿的时候表示读取数据/命令

6.RS引脚：高电平位数据、低电平位命令操作

#### 2-2-1：8080总线写时序

1.片选器件（CS），确定是写入命令还是写入数据（D/CX），把数据准备好（数据线），RDX保持高电平，WRX产生一个上升沿

![image-20231222195748877](pic\image-20231222195748877.png)

#### 2-2-1：8080总线读时序

1.片选器件（CS），确定是读取命令还是读取数据（D/CX），把数据准备好（数据线），WRX 保持高电平，RDX产生一个上升沿

![image-20231222195725025](pic\image-20231222195725025.png)



### 2-3；ILI9844几个重要的指令

#### 2-3-1：设备地址 0xD3

1.0xD3是用于读取设备地址的指令，发送0XD3命令，然后空读俩次，在读取俩次（第一个是高8位，第二次是低8位）

```c
uint16_t ret = 0
LCD8080_Write_Cmd(0xD3);
LCD_8080_Read_data();
LCD_8080_Read_data();
ret = LCD_8080_Read_data();
ret  << = 8;
ret |= LCD_8080_Read_data();
//此时的ret就是9844
```

#### 2-3-1：访问控制 0X36

1.该命令是用于控制读写GRAM相续读取GRAM的方向和决定像素点颜色编码的

2.先发送0x36，然后发送数据。D7控制的是y轴的方向，D6是控制x轴的方向，D5是控制是竖屏还是横屏，D3为控制颜色编码，0为BGR，1为RGB

![image-20231223203028234](pic\image-20231223203028234.png)

```c
LCD8080_Write_Cmd(0xD3);
LCD8080_Write_data(0x08);
```

#### 2-3-1：x轴0x2A

1.选择光标x轴的位置

2.先发送0x2A，然后发送发送起始坐标的高八位，然后发送起始坐标的低八位。接着发送终止坐标，和发送起始坐标一样

```c
LCD8080_Write_Cmd(0x2A);
LCD8080_Write_data(x_start >> 8);
LCD8080_Write_data(x_start & 0xff);
LCD8080_Write_data(x_end >> 8 );
LCD8080_Write_data(x_end & 0xff);
```

#### 2-3-1：y轴0x2B

1.选择光标x轴的位置

2.先发送0x2B，然后发送发送起始坐标的高八位，然后发送起始坐标的低八位。接着发送终止坐标，和发送起始坐标一样

```
LCD8080_Write_Cmd(0x2A);
LCD8080_Write_data(y_start >> 8);
LCD8080_Write_data(y_start & 0xff);
LCD8080_Write_data(y_end >> 8 );
LCD8080_Write_data(y_end & 0xff);
```

#### 2-3-1：写GRAM0x2c

1.决定写入像素点

2.先发送像素点数据

```c
LCD8080_Write_Cmd(0x2c);
LCD8080_Write_data(num1);
LCD8080_Write_data(num2);
LCD8080_Write_data(num3);

```

## 三、通过FSMC去模拟8080时序

### 3-1：何为FSMC

1.学名：灵活的静态存储控制器，也就是拿来读写控制器的一个外设，可以读取SRAM，NOR FLASH，NAND FLASH 和PC的存储器 

2.而FSMC刚刚好可以模拟出来8080时序，可以我们就通过FSMC来实现LCD的驱动

### 3-2：FSMC框图介绍

1.FSMC挂载在AHB总线上，也就是说时钟由于AHB直接提供，我们这里就是72mhz

2.寄存器配置器：用于配置FSMC不同配置工作方式

3.各位存储器控制器，及各种存储器用到的引脚口

4.公用的信号引脚有：FSCM_A[25:0]地址线 、FSCM_D[25:0] 数据线、FSCM_NOE写信号线、 FSCM_NWE读信号线、FSCM_WAIT等待信号。

![image-20231227160534829](pic\image-20231227160534829.png)

5.我们使用的是SRAM的接口，所以我们只关注NOR存储控制器：FSMC_EN使能 FSMC_NL地址有效，FSMC_NBL高字节使能，FSMC_CLK时钟使能。

 

### 3-3：FSMC映射

1.如图FSMC的映射的区域一个有四块，分别是一块NOR/PRSAM区域，俩块NAND闪存，一块PC卡区域

![image-20231227165008963](pic\image-20231227165008963.png)

2.其中每个区域都分为四块，NOR/PSRAM的区域中，我们对某一块的内存写入/读取操作，STM32就会自动片选我们的目标内存（FSMC_EN引脚口）。然后地址线就会根据地址数据自动的产生对应的电平(FSMC_A[25:0]),而数据线也会数据目标数据产生对应的电平信号(FSMC_D[15:0])

3.最后根据我们定义的时序，读写引脚口时序对应的电平跳变

4.也就是说我们设置好了FSMC，那么FSCM控制器就会帮我们进行数据的传输





### 3-4：FSMC是如何实现8080协议的

FSMC_NE对应到CS

FSMC_NEW对应到WR

FSMC_NOW对应到RD

FSMC_D[x]对应到DB

FSMC_A[x]对应到RS

#### 3-4-1：地址线对应到RS

1.如果我们要写入命令，那么RS线要保持一个低电平，前面我们知道写入不同的地址就会地址线就会有不同的电平，那么我们只需要写入不同的不同的地址就可以实习RS不同的电平

2.写操作

![image-20231230162751990](pic\image-20231230162751990.png)

读操作

![image-20231230162756303](pic\image-20231230162756303.png)



#### 3-4-2：地址换算

1.由于数据宽度是16位的和单片机的8位不同，所以实际写入的地址，和我们单片机映射的地址有偏移

2.在FSMC驱动SRAM的时候说过，单片机地址转化为SRAM地址的问题，在位宽是16位的情况下，你访问单片机的地址是0x68000000，由于是FSMC只有28根地址线所以要出去最高的4位，那么就会变成0x8000000，在出去用于片选块设备线也就是再去掉最高2为，就变成了0x000 0000（二进制000000000000000000000），在忽略掉最低位，并且HADDR1接到FSCM_A0过去也就是变成了0000000000000000000000，如果我们RS线是在FSCM_A23上面，那么我们就要让HADDR24这跟地址线为1，那么就是0x68000000 | （1 << 24），就是要访问上面哪个地址，为低就是上面哪个地址减一即可。

## 四、触摸芯片XPT2046

1.这事一款通过SPI协议进行数据通信的的触摸屏芯片

2.发送0xD0表示的是读取x轴被触摸的清空，0x90表示的是y轴被触摸的情况。

3.只有12位有效，需要进行一定的数据处理，还有就是通信发送的数据不是坐标，而是电压值，所以需要进行转算，也就是算出电压和点位的关系（触摸的点位越大，电压越大）

```c
SPI_XP_WriteReadBtye(0xD0);
	DelayNus(8);
	x = SPI_XP_WriteReadBtye(0x00);
	x <<= 8;
	x |= SPI_XP_WriteReadBtye(0x00);
	x >>= 4;
	SPI_XP_WriteReadBtye(0x90);
	DelayNus(8);
	y = SPI_XP_WriteReadBtye(0x00);
	y <<= 8;
	y |= SPI_XP_WriteReadBtye(0x00);
	y >>= 4;
```
